// Code generated by wunderctl. DO NOT EDIT.

import Fastify from "fastify";
import axios from "axios";
import {
	GetUsersResponse,
	CreateMessageResponse,
	CreateMessageInput,
	InternalCreateMessageInput,
	InjectedCreateMessageInput,
	GetMessagesResponse,
	GetMessagesInput,
	InternalGetMessagesInput,
	InjectedGetMessagesInput,
	GetUserResponse,
	InternalGetUserInput,
	InjectedGetUserInput,
	UpdateAvatarIdResponse,
	UpdateAvatarIdInput,
	InternalUpdateAvatarIdInput,
	InjectedUpdateAvatarIdInput,
	UpdateProfileResponse,
	UpdateProfileInput,
	InternalUpdateProfileInput,
	InjectedUpdateProfileInput,
	UserCreateResponse,
	UserCreateInput,
	InternalUserCreateInput,
	InjectedUserCreateInput,
	UserUpdateResponse,
	UserUpdateInput,
	InternalUserUpdateInput,
	InjectedUserUpdateInput,
	UserUpsertResponse,
	UserUpsertInput,
	InternalUserUpsertInput,
	InjectedUserUpsertInput,
} from "./models";
import { HooksConfiguration } from "@wundergraph/sdk/dist/configure";

declare module "fastify" {
	interface FastifyRequest {
		ctx: Context;
		setClientRequestHeaders: {
			[key: string]: string;
		};
	}
}

export interface WunderGraphRequestContext {
	user?: User;
	operationName: string;
	operationType: "mutation" | "query" | "subscription";
}

export interface Context {
	user?: User;
	clientRequest: ClientRequest;
	setClientRequestHeader: (name: string, value: string) => void;
}

export interface User {
	provider?: string;
	provider_id?: string;
	email?: string;
	email_verified?: boolean;
	name?: string;
	first_name?: string;
	last_name?: string;
	nick_name?: string;
	description?: string;
	user_id?: string;
	avatar_url?: string;
	location?: string;
	roles?: Role[];
	custom_attributes?: string[];
	custom_claims?: {
		[key: string]: any;
	};
}

export type Role = "admin" | "user";

export type AuthenticationResponse = AuthenticationOK | AuthenticationDeny;

export interface AuthenticationOK {
	status: "ok";
	user: User;
	message?: never;
}

export interface AuthenticationDeny {
	status: "deny";
	user?: never;
	message?: string;
}

const hooksToken = `Bearer ${process.env.HOOKS_TOKEN}`;

const internalRequest = async (operationName: string, input?: any): Promise<any> => {
	const url = "http://localhost:9991/internal/api/main/operations/" + operationName;
	const res = await axios.post(url, JSON.stringify(input || {}), {
		headers: {
			"Content-Type": "application/json",
			Authorization: hooksToken,
		},
	});
	return res.data;
};

interface InternalClient {
	queries: {
		GetUsers: () => Promise<GetUsersResponse>;
		GetMessages: (input: InternalGetMessagesInput) => Promise<GetMessagesResponse>;
		GetUser: (input: InternalGetUserInput) => Promise<GetUserResponse>;
	};
	mutations: {
		CreateMessage: (input: InternalCreateMessageInput) => Promise<CreateMessageResponse>;
		UpdateAvatarId: (input: InternalUpdateAvatarIdInput) => Promise<UpdateAvatarIdResponse>;
		UpdateProfile: (input: InternalUpdateProfileInput) => Promise<UpdateProfileResponse>;
		UserCreate: (input: InternalUserCreateInput) => Promise<UserCreateResponse>;
		UserUpdate: (input: InternalUserUpdateInput) => Promise<UserUpdateResponse>;
		UserUpsert: (input: InternalUserUpsertInput) => Promise<UserUpsertResponse>;
	};
}

const client = {
	queries: {
		GetUsers: async () => internalRequest("GetUsers"),
		GetMessages: async (input: InternalGetMessagesInput) => internalRequest("GetMessages", input),
		GetUser: async (input: InternalGetUserInput) => internalRequest("GetUser", input),
	},
	mutations: {
		CreateMessage: async (input: InternalCreateMessageInput) => internalRequest("CreateMessage", input),
		UpdateAvatarId: async (input: InternalUpdateAvatarIdInput) => internalRequest("UpdateAvatarId", input),
		UpdateProfile: async (input: InternalUpdateProfileInput) => internalRequest("UpdateProfile", input),
		UserCreate: async (input: InternalUserCreateInput) => internalRequest("UserCreate", input),
		UserUpdate: async (input: InternalUserUpdateInput) => internalRequest("UserUpdate", input),
		UserUpsert: async (input: InternalUserUpsertInput) => internalRequest("UserUpsert", input),
	},
};

// configureWunderGraphHooksWithClient configures the WunderGraph hooks with an injected client
// the client exposes all Operations, allowing you to implement side effects
// more info on how to use hooks can be found here: https://wundergraph.com/docs/overview/features/typesafe_hooks
// hooks reference docs: https://wundergraph.com/docs/reference/wundergraph_config_ts/overview
export const configureWunderGraphHooksWithClient = (config: (client: InternalClient) => HooksConfig) =>
	configureWunderGraphHooks(config(client));

export interface ClientRequest {
	method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "CONNECT" | "TRACE";
	requestURI: string;
	headers: {
		[key: string]: string;
	};
}

export interface WunderGraphRequest {
	method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "CONNECT" | "TRACE";
	requestURI: string;
	headers: {
		[key: string]: string;
	};
	body: any;
}

export interface WunderGraphResponse extends WunderGraphRequest {
	status: string;
	statusCode: number;
}

// use SKIP to skip the hook and continue the request / response chain without modifying the request / response
export type SKIP = "skip";

// use CANCEL to skip the hook and cancel the request / response chain
// this is semantically equal to throwing an error (500)
export type CANCEL = "cancel";

export type WUNDERGRAPH_OPERATION =
	| "GetUsers"
	| "CreateMessage"
	| "GetMessages"
	| "GetUser"
	| "UpdateAvatarId"
	| "UpdateProfile"
	| "UserCreate"
	| "UserUpdate"
	| "UserUpsert";

export interface GlobalHooksConfig {
	httpTransport?: {
		// onRequest is called right before the request is sent
		// it can be used to modify the request
		// you can return SKIP to skip the hook and continue the request chain without modifying the request
		// you can return CANCEL to cancel the request chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onRequest?: {
			hook: (
				ctx: WunderGraphRequestContext,
				request: WunderGraphRequest
			) => Promise<WunderGraphRequest | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
		// onResponse is called right after the response is received
		// it can be used to modify the response
		// you can return SKIP to skip the hook and continue the response chain without modifying the response
		// you can return CANCEL to cancel the response chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onResponse?: {
			hook: (
				ctx: WunderGraphRequestContext,
				response: WunderGraphResponse
			) => Promise<WunderGraphResponse | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
	};
}
export type JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;

export type JSONObject = { [key: string]: JSONValue };

export interface HooksConfig {
	global?: GlobalHooksConfig;
	authentication?: {
		postAuthentication?: (user: User, accessToken: JSONObject, idToken: JSONObject) => Promise<void>;
		mutatingPostAuthentication?: (
			user: User,
			accessToken: JSONObject,
			idToken: JSONObject
		) => Promise<AuthenticationResponse>;
		revalidate?: (user: User, accessToken: JSONObject, idToken: JSONObject) => Promise<AuthenticationResponse>;
	};
	queries?: {
		GetUsers?: {
			mockResolve?: (ctx: Context) => Promise<GetUsersResponse>;
			preResolve?: (ctx: Context) => Promise<void>;
			postResolve?: (ctx: Context, response: GetUsersResponse) => Promise<void>;
			customResolve?: (ctx: Context) => Promise<void | GetUsersResponse>;
			mutatingPostResolve?: (ctx: Context, response: GetUsersResponse) => Promise<GetUsersResponse>;
		};
		GetMessages?: {
			mockResolve?: (ctx: Context, input: InjectedGetMessagesInput) => Promise<GetMessagesResponse>;
			preResolve?: (ctx: Context, input: InjectedGetMessagesInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedGetMessagesInput) => Promise<InjectedGetMessagesInput>;
			postResolve?: (ctx: Context, input: InjectedGetMessagesInput, response: GetMessagesResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedGetMessagesInput) => Promise<void | GetMessagesResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedGetMessagesInput,
				response: GetMessagesResponse
			) => Promise<GetMessagesResponse>;
		};
		GetUser?: {
			mockResolve?: (ctx: Context, input: InjectedGetUserInput) => Promise<GetUserResponse>;
			preResolve?: (ctx: Context, input: InjectedGetUserInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedGetUserInput) => Promise<InjectedGetUserInput>;
			postResolve?: (ctx: Context, input: InjectedGetUserInput, response: GetUserResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedGetUserInput) => Promise<void | GetUserResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedGetUserInput,
				response: GetUserResponse
			) => Promise<GetUserResponse>;
		};
	};
	mutations?: {
		CreateMessage?: {
			mockResolve?: (ctx: Context, input: InjectedCreateMessageInput) => Promise<CreateMessageResponse>;
			preResolve?: (ctx: Context, input: InjectedCreateMessageInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedCreateMessageInput) => Promise<InjectedCreateMessageInput>;
			postResolve?: (ctx: Context, input: InjectedCreateMessageInput, response: CreateMessageResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedCreateMessageInput) => Promise<void | CreateMessageResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedCreateMessageInput,
				response: CreateMessageResponse
			) => Promise<CreateMessageResponse>;
		};
		UpdateAvatarId?: {
			mockResolve?: (ctx: Context, input: InjectedUpdateAvatarIdInput) => Promise<UpdateAvatarIdResponse>;
			preResolve?: (ctx: Context, input: InjectedUpdateAvatarIdInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedUpdateAvatarIdInput) => Promise<InjectedUpdateAvatarIdInput>;
			postResolve?: (
				ctx: Context,
				input: InjectedUpdateAvatarIdInput,
				response: UpdateAvatarIdResponse
			) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedUpdateAvatarIdInput) => Promise<void | UpdateAvatarIdResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedUpdateAvatarIdInput,
				response: UpdateAvatarIdResponse
			) => Promise<UpdateAvatarIdResponse>;
		};
		UpdateProfile?: {
			mockResolve?: (ctx: Context, input: InjectedUpdateProfileInput) => Promise<UpdateProfileResponse>;
			preResolve?: (ctx: Context, input: InjectedUpdateProfileInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedUpdateProfileInput) => Promise<InjectedUpdateProfileInput>;
			postResolve?: (ctx: Context, input: InjectedUpdateProfileInput, response: UpdateProfileResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedUpdateProfileInput) => Promise<void | UpdateProfileResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedUpdateProfileInput,
				response: UpdateProfileResponse
			) => Promise<UpdateProfileResponse>;
		};
		UserCreate?: {
			mockResolve?: (ctx: Context, input: InjectedUserCreateInput) => Promise<UserCreateResponse>;
			preResolve?: (ctx: Context, input: InjectedUserCreateInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedUserCreateInput) => Promise<InjectedUserCreateInput>;
			postResolve?: (ctx: Context, input: InjectedUserCreateInput, response: UserCreateResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedUserCreateInput) => Promise<void | UserCreateResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedUserCreateInput,
				response: UserCreateResponse
			) => Promise<UserCreateResponse>;
		};
		UserUpdate?: {
			mockResolve?: (ctx: Context, input: InjectedUserUpdateInput) => Promise<UserUpdateResponse>;
			preResolve?: (ctx: Context, input: InjectedUserUpdateInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedUserUpdateInput) => Promise<InjectedUserUpdateInput>;
			postResolve?: (ctx: Context, input: InjectedUserUpdateInput, response: UserUpdateResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedUserUpdateInput) => Promise<void | UserUpdateResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedUserUpdateInput,
				response: UserUpdateResponse
			) => Promise<UserUpdateResponse>;
		};
		UserUpsert?: {
			mockResolve?: (ctx: Context, input: InjectedUserUpsertInput) => Promise<UserUpsertResponse>;
			preResolve?: (ctx: Context, input: InjectedUserUpsertInput) => Promise<void>;
			mutatingPreResolve?: (ctx: Context, input: InjectedUserUpsertInput) => Promise<InjectedUserUpsertInput>;
			postResolve?: (ctx: Context, input: InjectedUserUpsertInput, response: UserUpsertResponse) => Promise<void>;
			customResolve?: (ctx: Context, input: InjectedUserUpsertInput) => Promise<void | UserUpsertResponse>;
			mutatingPostResolve?: (
				ctx: Context,
				input: InjectedUserUpsertInput,
				response: UserUpsertResponse
			) => Promise<UserUpsertResponse>;
		};
	};
}

// configureWunderGraphHooks configures the WunderGraph hooks without injecting an internal client
// more info on how to use hooks can be found here: https://wundergraph.com/docs/overview/features/typesafe_hooks
// hooks reference docs: https://wundergraph.com/docs/reference/wundergraph_config_ts/overview
export const configureWunderGraphHooks = (config: HooksConfig) => {
	const hooksConfig: HooksConfiguration = {
		global: config.global,
		queries: config.queries as { [name: string]: { preResolve: any; postResolve: any; mutatingPostResolve: any } },
		mutations: config.mutations as { [name: string]: { preResolve: any; postResolve: any; mutatingPostResolve: any } },
		authentication: config.authentication as {
			postAuthentication?: any;
			mutatingPostAuthentication?: any;
			revalidate?: any;
		},
	};
	const server = {
		config: hooksConfig,
		start() {
			const fastify = Fastify({
				logger: true,
			});

			fastify.addHook<{ Body: { user: User; clientRequest: ClientRequest } }>("preHandler", async (req, reply) => {
				req.setClientRequestHeaders = {};
				req.ctx = {
					user: req?.body?.user,
					clientRequest: req?.body?.clientRequest || {
						headers: {},
						requestURI: "",
						method: "GET",
					},
					setClientRequestHeader: (name, value) => (req.setClientRequestHeaders[name] = value),
				};
			});

			// authentication
			fastify.post<{ Body: { access_token: any; id_token: any } }>(
				"/authentication/postAuthentication",
				async (request, reply) => {
					reply.type("application/json").code(200);
					if (config.authentication?.postAuthentication !== undefined && request.ctx.user !== undefined) {
						try {
							await config.authentication.postAuthentication(
								request.ctx.user,
								request.body.access_token || {},
								request.body.id_token || {}
							);
						} catch (err) {
							request.log.error(err);
							reply.code(500);
							return { hook: "postAuthentication", error: err };
						}
					}
					return {
						hook: "postAuthentication",
					};
				}
			);
			fastify.post<{ Body: { access_token: any; id_token: any } }>(
				"/authentication/mutatingPostAuthentication",
				async (request, reply) => {
					reply.type("application/json").code(200);
					if (config.authentication?.mutatingPostAuthentication !== undefined && request.ctx.user !== undefined) {
						try {
							const out = await config.authentication.mutatingPostAuthentication(
								request.ctx.user,
								request.body.access_token || {},
								request.body.id_token || {}
							);
							return {
								hook: "mutatingPostAuthentication",
								response: out,
								setClientRequestHeaders: request.setClientRequestHeaders,
							};
						} catch (err) {
							request.log.error(err);
							reply.code(500);
							return { hook: "mutatingPostAuthentication", error: err };
						}
					}
				}
			);
			fastify.post<{ Body: { access_token: any; id_token: any } }>(
				"/authentication/revalidateAuthentication",
				async (request, reply) => {
					reply.type("application/json").code(200);
					if (config.authentication?.revalidate !== undefined && request.ctx.user !== undefined) {
						try {
							const out = await config.authentication.revalidate(
								request.ctx.user,
								request.body.access_token || {},
								request.body.id_token || {}
							);
							return {
								hook: "revalidateAuthentication",
								response: out,
								setClientRequestHeaders: request.setClientRequestHeaders,
							};
						} catch (err) {
							request.log.error(err);
							reply.code(500);
							return { hook: "revalidateAuthentication", error: err };
						}
					}
				}
			);

			// global hooks

			// httpTransport

			fastify.post<{
				Body: {
					request: WunderGraphRequest;
					operationName: string;
					operationType: "query" | "mutation" | "subscription";
				};
			}>("/global/httpTransport/onRequest", async (request, reply) => {
				reply.type("application/json").code(200);
				try {
					const maybeHookOut = await config.global?.httpTransport?.onRequest?.hook(
						{
							user: request.ctx.user,
							operationName: request.body.operationName,
							operationType: request.body.operationType,
						},
						request.body.request
					);
					const hookOut = maybeHookOut || "skip";
					return {
						op: request.body.operationName,
						hook: "onRequest",
						response: {
							skip: hookOut === "skip",
							cancel: hookOut === "cancel",
							request: hookOut !== "skip" && hookOut !== "cancel" ? hookOut : undefined,
						},
					};
				} catch (err) {
					request.log.error(err);
					reply.code(500);
					return { op: "Messages", hook: "postResolve", error: err };
				}
			});

			fastify.post<{
				Body: {
					response: WunderGraphResponse;
					operationName: string;
					operationType: "query" | "mutation" | "subscription";
				};
			}>("/global/httpTransport/onResponse", async (request, reply) => {
				reply.type("application/json").code(200);
				try {
					const maybeHookOut = await config.global?.httpTransport?.onResponse?.hook(
						{
							user: request.ctx.user,
							operationName: request.body.operationName,
							operationType: request.body.operationType,
						},
						request.body.response
					);
					const hookOut = maybeHookOut || "skip";
					return {
						op: request.body.operationName,
						hook: "onResponse",
						response: {
							skip: hookOut === "skip",
							cancel: hookOut === "cancel",
							response: hookOut !== "skip" && hookOut !== "cancel" ? hookOut : undefined,
						},
					};
				} catch (err) {
					request.log.error(err);
					reply.code(500);
					return { op: "Messages", hook: "postResolve", error: err };
				}
			});

			/**
			 * Queries
			 */

			// mock
			fastify.post("/operation/GetUsers/mockResolve", async (request, reply) => {
				reply.type("application/json").code(200);
				try {
					const mutated = await config?.queries?.GetUsers?.mockResolve?.(request.ctx);
					return {
						op: "GetUsers",
						hook: "mock",
						response: mutated,
						setClientRequestHeaders: request.setClientRequestHeaders,
					};
				} catch (err) {
					request.log.error(err);
					reply.code(500);
					return { op: "GetUsers", hook: "mock", error: err };
				}
			});

			// preResolve
			fastify.post("/operation/GetUsers/preResolve", async (request, reply) => {
				reply.type("application/json").code(200);
				try {
					await config?.queries?.GetUsers?.preResolve?.(request.ctx);
					return {
						op: "GetUsers",
						hook: "preResolve",
						setClientRequestHeaders: request.setClientRequestHeaders,
					};
				} catch (err) {
					request.log.error(err);
					reply.code(500);
					return { op: "GetUsers", hook: "preResolve", error: err };
				}
			});
			// postResolve
			fastify.post<{ Body: { response: GetUsersResponse } }>(
				"/operation/GetUsers/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.queries?.GetUsers?.postResolve?.(request.ctx, request.body.response);
						return {
							op: "GetUsers",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUsers", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { response: GetUsersResponse } }>(
				"/operation/GetUsers/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetUsers?.mutatingPostResolve?.(request.ctx, request.body.response);
						return {
							op: "GetUsers",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUsers", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: {} }>("/operation/GetUsers/customResolve", async (request, reply) => {
				reply.type("application/json").code(200);
				try {
					const out = await config?.queries?.GetUsers?.customResolve?.(request.ctx);
					return {
						op: "GetUsers",
						hook: "customResolve",
						response: out || null,
						setClientRequestHeaders: request.setClientRequestHeaders,
					};
				} catch (err) {
					request.log.error(err);
					reply.code(500);
					return { op: "GetUsers", hook: "customResolve", error: err };
				}
			});

			// mock
			fastify.post<{ Body: { input: InjectedGetMessagesInput } }>(
				"/operation/GetMessages/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetMessages?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "GetMessages",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedGetMessagesInput } }>(
				"/operation/GetMessages/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.queries?.GetMessages?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "GetMessages",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedGetMessagesInput; response: GetMessagesResponse } }>(
				"/operation/GetMessages/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.queries?.GetMessages?.postResolve?.(request.ctx, request.body.input, request.body.response);
						return {
							op: "GetMessages",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedGetMessagesInput } }>(
				"/operation/GetMessages/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetMessages?.mutatingPreResolve?.(request.ctx, request.body.input);
						return {
							op: "GetMessages",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedGetMessagesInput; response: GetMessagesResponse } }>(
				"/operation/GetMessages/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetMessages?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "GetMessages",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedGetMessagesInput } }>(
				"/operation/GetMessages/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.queries?.GetMessages?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "GetMessages",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetMessages", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedGetUserInput } }>(
				"/operation/GetUser/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetUser?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "GetUser",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedGetUserInput } }>(
				"/operation/GetUser/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.queries?.GetUser?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "GetUser",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedGetUserInput; response: GetUserResponse } }>(
				"/operation/GetUser/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.queries?.GetUser?.postResolve?.(request.ctx, request.body.input, request.body.response);
						return {
							op: "GetUser",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedGetUserInput } }>(
				"/operation/GetUser/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetUser?.mutatingPreResolve?.(request.ctx, request.body.input);
						return {
							op: "GetUser",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedGetUserInput; response: GetUserResponse } }>(
				"/operation/GetUser/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.queries?.GetUser?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "GetUser",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedGetUserInput } }>(
				"/operation/GetUser/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.queries?.GetUser?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "GetUser",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "GetUser", hook: "customResolve", error: err };
					}
				}
			);

			/**
			 * Mutations
			 */

			// mock
			fastify.post<{ Body: { input: InjectedCreateMessageInput } }>(
				"/operation/CreateMessage/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.CreateMessage?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "CreateMessage",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedCreateMessageInput } }>(
				"/operation/CreateMessage/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.CreateMessage?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "CreateMessage",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedCreateMessageInput; response: CreateMessageResponse } }>(
				"/operation/CreateMessage/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.CreateMessage?.postResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "CreateMessage",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedCreateMessageInput } }>(
				"/operation/CreateMessage/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.CreateMessage?.mutatingPreResolve?.(
							request.ctx,
							request.body.input
						);
						return {
							op: "CreateMessage",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedCreateMessageInput; response: CreateMessageResponse } }>(
				"/operation/CreateMessage/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.CreateMessage?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "CreateMessage",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedCreateMessageInput } }>(
				"/operation/CreateMessage/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.CreateMessage?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "CreateMessage",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "CreateMessage", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput } }>(
				"/operation/UpdateAvatarId/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateAvatarId?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateAvatarId",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput } }>(
				"/operation/UpdateAvatarId/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UpdateAvatarId?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateAvatarId",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput; response: UpdateAvatarIdResponse } }>(
				"/operation/UpdateAvatarId/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UpdateAvatarId?.postResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UpdateAvatarId",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput } }>(
				"/operation/UpdateAvatarId/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateAvatarId?.mutatingPreResolve?.(
							request.ctx,
							request.body.input
						);
						return {
							op: "UpdateAvatarId",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput; response: UpdateAvatarIdResponse } }>(
				"/operation/UpdateAvatarId/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateAvatarId?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UpdateAvatarId",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedUpdateAvatarIdInput } }>(
				"/operation/UpdateAvatarId/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.UpdateAvatarId?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateAvatarId",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateAvatarId", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedUpdateProfileInput } }>(
				"/operation/UpdateProfile/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateProfile?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateProfile",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedUpdateProfileInput } }>(
				"/operation/UpdateProfile/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UpdateProfile?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateProfile",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedUpdateProfileInput; response: UpdateProfileResponse } }>(
				"/operation/UpdateProfile/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UpdateProfile?.postResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UpdateProfile",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedUpdateProfileInput } }>(
				"/operation/UpdateProfile/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateProfile?.mutatingPreResolve?.(
							request.ctx,
							request.body.input
						);
						return {
							op: "UpdateProfile",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedUpdateProfileInput; response: UpdateProfileResponse } }>(
				"/operation/UpdateProfile/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UpdateProfile?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UpdateProfile",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedUpdateProfileInput } }>(
				"/operation/UpdateProfile/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.UpdateProfile?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "UpdateProfile",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UpdateProfile", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedUserCreateInput } }>(
				"/operation/UserCreate/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserCreate?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "UserCreate",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedUserCreateInput } }>(
				"/operation/UserCreate/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserCreate?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "UserCreate",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedUserCreateInput; response: UserCreateResponse } }>(
				"/operation/UserCreate/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserCreate?.postResolve?.(request.ctx, request.body.input, request.body.response);
						return {
							op: "UserCreate",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedUserCreateInput } }>(
				"/operation/UserCreate/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserCreate?.mutatingPreResolve?.(request.ctx, request.body.input);
						return {
							op: "UserCreate",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedUserCreateInput; response: UserCreateResponse } }>(
				"/operation/UserCreate/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserCreate?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UserCreate",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedUserCreateInput } }>(
				"/operation/UserCreate/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.UserCreate?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "UserCreate",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserCreate", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedUserUpdateInput } }>(
				"/operation/UserUpdate/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpdate?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpdate",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedUserUpdateInput } }>(
				"/operation/UserUpdate/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserUpdate?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpdate",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedUserUpdateInput; response: UserUpdateResponse } }>(
				"/operation/UserUpdate/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserUpdate?.postResolve?.(request.ctx, request.body.input, request.body.response);
						return {
							op: "UserUpdate",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedUserUpdateInput } }>(
				"/operation/UserUpdate/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpdate?.mutatingPreResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpdate",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedUserUpdateInput; response: UserUpdateResponse } }>(
				"/operation/UserUpdate/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpdate?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UserUpdate",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedUserUpdateInput } }>(
				"/operation/UserUpdate/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.UserUpdate?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpdate",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpdate", hook: "customResolve", error: err };
					}
				}
			);

			// mock
			fastify.post<{ Body: { input: InjectedUserUpsertInput } }>(
				"/operation/UserUpsert/mockResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpsert?.mockResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpsert",
							hook: "mock",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "mock", error: err };
					}
				}
			);

			// preResolve
			fastify.post<{ Body: { input: InjectedUserUpsertInput } }>(
				"/operation/UserUpsert/preResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserUpsert?.preResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpsert",
							hook: "preResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "preResolve", error: err };
					}
				}
			);
			// postResolve
			fastify.post<{ Body: { input: InjectedUserUpsertInput; response: UserUpsertResponse } }>(
				"/operation/UserUpsert/postResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						await config?.mutations?.UserUpsert?.postResolve?.(request.ctx, request.body.input, request.body.response);
						return {
							op: "UserUpsert",
							hook: "postResolve",
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "postResolve", error: err };
					}
				}
			);
			// mutatingPreResolve
			fastify.post<{ Body: { input: InjectedUserUpsertInput } }>(
				"/operation/UserUpsert/mutatingPreResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpsert?.mutatingPreResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpsert",
							hook: "mutatingPreResolve",
							input: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "mutatingPreResolve", error: err };
					}
				}
			);
			// mutatingPostResolve
			fastify.post<{ Body: { input: InjectedUserUpsertInput; response: UserUpsertResponse } }>(
				"/operation/UserUpsert/mutatingPostResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const mutated = await config?.mutations?.UserUpsert?.mutatingPostResolve?.(
							request.ctx,
							request.body.input,
							request.body.response
						);
						return {
							op: "UserUpsert",
							hook: "mutatingPostResolve",
							response: mutated,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "mutatingPostResolve", error: err };
					}
				}
			);
			// customResolve
			fastify.post<{ Body: { input: InjectedUserUpsertInput } }>(
				"/operation/UserUpsert/customResolve",
				async (request, reply) => {
					reply.type("application/json").code(200);
					try {
						const out = await config?.mutations?.UserUpsert?.customResolve?.(request.ctx, request.body.input);
						return {
							op: "UserUpsert",
							hook: "customResolve",
							response: out || null,
							setClientRequestHeaders: request.setClientRequestHeaders,
						};
					} catch (err) {
						request.log.error(err);
						reply.code(500);
						return { op: "UserUpsert", hook: "customResolve", error: err };
					}
				}
			);

			fastify.listen(9992, "127.0.0.1", (err, address) => {
				if (err) {
					console.error(err);
					process.exit(0);
				}
				console.log(`hooks server listening at ${address}`);
			});
		},
	};

	if (process.env.START_HOOKS_SERVER === "true") {
		server.start();
	}

	return server;
};
