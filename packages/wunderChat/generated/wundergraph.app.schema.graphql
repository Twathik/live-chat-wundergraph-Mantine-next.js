# Code generated by "wunderctl"; DO NOT EDIT.

directive @fromClaim(name: Claim) on VARIABLE_DEFINITION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
) on VARIABLE_DEFINITION

directive @rbac(
  """the user must match all roles"""
  requireMatchAll: [WG_ROLE]
  """the user must match at least one of the roles"""
  requireMatchAny: [WG_ROLE]
  """the user must not match all of the roles"""
  denyMatchAll: [WG_ROLE]
  """the user must not match any of the roles"""
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """customFormat must conform to the Golang specification for specifying a date time format"""
  customFormat: String
) on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition."""
directive @injectEnvironmentVariable(name: String!) on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

input usersDb_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: usersDb_NestedIntFilter
}

input usersDb_IntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: usersDb_NestedIntFilter
}

enum usersDb_QueryMode {
  default
  insensitive
}

input usersDb_NestedStringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: usersDb_NestedStringNullableFilter
}

input usersDb_StringNullableFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: usersDb_QueryMode
  not: usersDb_NestedStringNullableFilter
}

input usersDb_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: usersDb_NestedDateTimeFilter
}

input usersDb_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: usersDb_NestedDateTimeFilter
}

input usersDb_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: usersDb_NestedStringFilter
}

input usersDb_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: usersDb_QueryMode
  not: usersDb_NestedStringFilter
}

input usersDb_ChatListRelationFilter {
  every: usersDb_ChatWhereInput
  some: usersDb_ChatWhereInput
  none: usersDb_ChatWhereInput
}

input usersDb_UserWhereInput {
  AND: usersDb_UserWhereInput
  OR: [usersDb_UserWhereInput]
  NOT: usersDb_UserWhereInput
  id: usersDb_IntFilter
  email: usersDb_StringFilter
  lastName: usersDb_StringFilter
  firstName: usersDb_StringFilter
  name: usersDb_StringFilter
  userId: usersDb_StringFilter
  avatarId: usersDb_StringNullableFilter
  Chat: usersDb_ChatListRelationFilter
}

input usersDb_UserRelationFilter {
  is: usersDb_UserWhereInput
  isNot: usersDb_UserWhereInput
}

input usersDb_ChatWhereInput {
  AND: usersDb_ChatWhereInput
  OR: [usersDb_ChatWhereInput]
  NOT: usersDb_ChatWhereInput
  id: usersDb_IntFilter
  message: usersDb_StringNullableFilter
  createdAt: usersDb_DateTimeFilter
  userId: usersDb_IntFilter
  User: usersDb_UserRelationFilter
}

enum usersDb_SortOrder {
  asc
  desc
}

input usersDb_ChatOrderByRelationAggregateInput {
  _count: usersDb_SortOrder
}

input usersDb_UserOrderByWithRelationInput {
  id: usersDb_SortOrder
  email: usersDb_SortOrder
  lastName: usersDb_SortOrder
  firstName: usersDb_SortOrder
  name: usersDb_SortOrder
  userId: usersDb_SortOrder
  avatarId: usersDb_SortOrder
  Chat: usersDb_ChatOrderByRelationAggregateInput
}

input usersDb_ChatOrderByWithRelationInput {
  id: usersDb_SortOrder
  message: usersDb_SortOrder
  createdAt: usersDb_SortOrder
  userId: usersDb_SortOrder
  User: usersDb_UserOrderByWithRelationInput
}

input usersDb_ChatWhereUniqueInput {
  id: Int
}

enum usersDb_ChatScalarFieldEnum {
  id
  message
  createdAt
  userId
}

type usersDb_UserCountOutputType {
  Chat: Int!
  _join: Query!
}

type usersDb_User {
  id: Int!
  email: String!
  lastName: String!
  firstName: String!
  name: String!
  userId: String!
  avatarId: String
  Chat(where: usersDb_ChatWhereInput, orderBy: [usersDb_ChatOrderByWithRelationInput], cursor: usersDb_ChatWhereUniqueInput, take: Int, skip: Int, distinct: [usersDb_ChatScalarFieldEnum]): [usersDb_Chat]
  _count: usersDb_UserCountOutputType
  _join: Query!
}

type usersDb_Chat {
  id: Int!
  message: String
  createdAt: DateTime!
  userId: Int!
  User: usersDb_User!
  _join: Query!
}

type usersDb_ChatCountAggregateOutputType {
  id: Int!
  message: Int!
  createdAt: Int!
  userId: Int!
  _all: Int!
  _join: Query!
}

type usersDb_ChatAvgAggregateOutputType {
  id: Float
  userId: Float
  _join: Query!
}

type usersDb_ChatSumAggregateOutputType {
  id: Int
  userId: Int
  _join: Query!
}

type usersDb_ChatMinAggregateOutputType {
  id: Int
  message: String
  createdAt: DateTime
  userId: Int
  _join: Query!
}

type usersDb_ChatMaxAggregateOutputType {
  id: Int
  message: String
  createdAt: DateTime
  userId: Int
  _join: Query!
}

type usersDb_AggregateChat {
  _count: usersDb_ChatCountAggregateOutputType
  _avg: usersDb_ChatAvgAggregateOutputType
  _sum: usersDb_ChatSumAggregateOutputType
  _min: usersDb_ChatMinAggregateOutputType
  _max: usersDb_ChatMaxAggregateOutputType
  _join: Query!
}

input usersDb_ChatCountOrderByAggregateInput {
  id: usersDb_SortOrder
  message: usersDb_SortOrder
  createdAt: usersDb_SortOrder
  userId: usersDb_SortOrder
}

input usersDb_ChatAvgOrderByAggregateInput {
  id: usersDb_SortOrder
  userId: usersDb_SortOrder
}

input usersDb_ChatMaxOrderByAggregateInput {
  id: usersDb_SortOrder
  message: usersDb_SortOrder
  createdAt: usersDb_SortOrder
  userId: usersDb_SortOrder
}

input usersDb_ChatMinOrderByAggregateInput {
  id: usersDb_SortOrder
  message: usersDb_SortOrder
  createdAt: usersDb_SortOrder
  userId: usersDb_SortOrder
}

input usersDb_ChatSumOrderByAggregateInput {
  id: usersDb_SortOrder
  userId: usersDb_SortOrder
}

input usersDb_ChatOrderByWithAggregationInput {
  id: usersDb_SortOrder
  message: usersDb_SortOrder
  createdAt: usersDb_SortOrder
  userId: usersDb_SortOrder
  _count: usersDb_ChatCountOrderByAggregateInput
  _avg: usersDb_ChatAvgOrderByAggregateInput
  _max: usersDb_ChatMaxOrderByAggregateInput
  _min: usersDb_ChatMinOrderByAggregateInput
  _sum: usersDb_ChatSumOrderByAggregateInput
}

input usersDb_NestedFloatFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: usersDb_NestedFloatFilter
}

input usersDb_NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: usersDb_NestedIntWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _avg: usersDb_NestedFloatFilter
  _sum: usersDb_NestedIntFilter
  _min: usersDb_NestedIntFilter
  _max: usersDb_NestedIntFilter
}

input usersDb_IntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: usersDb_NestedIntWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _avg: usersDb_NestedFloatFilter
  _sum: usersDb_NestedIntFilter
  _min: usersDb_NestedIntFilter
  _max: usersDb_NestedIntFilter
}

input usersDb_NestedIntNullableFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: usersDb_NestedIntNullableFilter
}

input usersDb_NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: usersDb_NestedStringNullableWithAggregatesFilter
  _count: usersDb_NestedIntNullableFilter
  _min: usersDb_NestedStringNullableFilter
  _max: usersDb_NestedStringNullableFilter
}

input usersDb_StringNullableWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: usersDb_QueryMode
  not: usersDb_NestedStringNullableWithAggregatesFilter
  _count: usersDb_NestedIntNullableFilter
  _min: usersDb_NestedStringNullableFilter
  _max: usersDb_NestedStringNullableFilter
}

input usersDb_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: usersDb_NestedDateTimeWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _min: usersDb_NestedDateTimeFilter
  _max: usersDb_NestedDateTimeFilter
}

input usersDb_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: usersDb_NestedDateTimeWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _min: usersDb_NestedDateTimeFilter
  _max: usersDb_NestedDateTimeFilter
}

input usersDb_ChatScalarWhereWithAggregatesInput {
  AND: usersDb_ChatScalarWhereWithAggregatesInput
  OR: [usersDb_ChatScalarWhereWithAggregatesInput]
  NOT: usersDb_ChatScalarWhereWithAggregatesInput
  id: usersDb_IntWithAggregatesFilter
  message: usersDb_StringNullableWithAggregatesFilter
  createdAt: usersDb_DateTimeWithAggregatesFilter
  userId: usersDb_IntWithAggregatesFilter
}

type usersDb_ChatGroupByOutputType {
  id: Int!
  message: String
  createdAt: DateTime!
  userId: Int!
  _count: usersDb_ChatCountAggregateOutputType
  _avg: usersDb_ChatAvgAggregateOutputType
  _sum: usersDb_ChatSumAggregateOutputType
  _min: usersDb_ChatMinAggregateOutputType
  _max: usersDb_ChatMaxAggregateOutputType
  _join: Query!
}

input usersDb_UserWhereUniqueInput {
  id: Int
  email: String
  userId: String
}

enum usersDb_UserScalarFieldEnum {
  id
  email
  lastName
  firstName
  name
  userId
  avatarId
}

type usersDb_UserCountAggregateOutputType {
  id: Int!
  email: Int!
  lastName: Int!
  firstName: Int!
  name: Int!
  userId: Int!
  avatarId: Int!
  _all: Int!
  _join: Query!
}

type usersDb_UserAvgAggregateOutputType {
  id: Float
  _join: Query!
}

type usersDb_UserSumAggregateOutputType {
  id: Int
  _join: Query!
}

type usersDb_UserMinAggregateOutputType {
  id: Int
  email: String
  lastName: String
  firstName: String
  name: String
  userId: String
  avatarId: String
  _join: Query!
}

type usersDb_UserMaxAggregateOutputType {
  id: Int
  email: String
  lastName: String
  firstName: String
  name: String
  userId: String
  avatarId: String
  _join: Query!
}

type usersDb_AggregateUser {
  _count: usersDb_UserCountAggregateOutputType
  _avg: usersDb_UserAvgAggregateOutputType
  _sum: usersDb_UserSumAggregateOutputType
  _min: usersDb_UserMinAggregateOutputType
  _max: usersDb_UserMaxAggregateOutputType
  _join: Query!
}

input usersDb_UserCountOrderByAggregateInput {
  id: usersDb_SortOrder
  email: usersDb_SortOrder
  lastName: usersDb_SortOrder
  firstName: usersDb_SortOrder
  name: usersDb_SortOrder
  userId: usersDb_SortOrder
  avatarId: usersDb_SortOrder
}

input usersDb_UserAvgOrderByAggregateInput {
  id: usersDb_SortOrder
}

input usersDb_UserMaxOrderByAggregateInput {
  id: usersDb_SortOrder
  email: usersDb_SortOrder
  lastName: usersDb_SortOrder
  firstName: usersDb_SortOrder
  name: usersDb_SortOrder
  userId: usersDb_SortOrder
  avatarId: usersDb_SortOrder
}

input usersDb_UserMinOrderByAggregateInput {
  id: usersDb_SortOrder
  email: usersDb_SortOrder
  lastName: usersDb_SortOrder
  firstName: usersDb_SortOrder
  name: usersDb_SortOrder
  userId: usersDb_SortOrder
  avatarId: usersDb_SortOrder
}

input usersDb_UserSumOrderByAggregateInput {
  id: usersDb_SortOrder
}

input usersDb_UserOrderByWithAggregationInput {
  id: usersDb_SortOrder
  email: usersDb_SortOrder
  lastName: usersDb_SortOrder
  firstName: usersDb_SortOrder
  name: usersDb_SortOrder
  userId: usersDb_SortOrder
  avatarId: usersDb_SortOrder
  _count: usersDb_UserCountOrderByAggregateInput
  _avg: usersDb_UserAvgOrderByAggregateInput
  _max: usersDb_UserMaxOrderByAggregateInput
  _min: usersDb_UserMinOrderByAggregateInput
  _sum: usersDb_UserSumOrderByAggregateInput
}

input usersDb_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: usersDb_NestedStringWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _min: usersDb_NestedStringFilter
  _max: usersDb_NestedStringFilter
}

input usersDb_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: usersDb_QueryMode
  not: usersDb_NestedStringWithAggregatesFilter
  _count: usersDb_NestedIntFilter
  _min: usersDb_NestedStringFilter
  _max: usersDb_NestedStringFilter
}

input usersDb_UserScalarWhereWithAggregatesInput {
  AND: usersDb_UserScalarWhereWithAggregatesInput
  OR: [usersDb_UserScalarWhereWithAggregatesInput]
  NOT: usersDb_UserScalarWhereWithAggregatesInput
  id: usersDb_IntWithAggregatesFilter
  email: usersDb_StringWithAggregatesFilter
  lastName: usersDb_StringWithAggregatesFilter
  firstName: usersDb_StringWithAggregatesFilter
  name: usersDb_StringWithAggregatesFilter
  userId: usersDb_StringWithAggregatesFilter
  avatarId: usersDb_StringNullableWithAggregatesFilter
}

type usersDb_UserGroupByOutputType {
  id: Int!
  email: String!
  lastName: String!
  firstName: String!
  name: String!
  userId: String!
  avatarId: String
  _count: usersDb_UserCountAggregateOutputType
  _avg: usersDb_UserAvgAggregateOutputType
  _sum: usersDb_UserSumAggregateOutputType
  _min: usersDb_UserMinAggregateOutputType
  _max: usersDb_UserMaxAggregateOutputType
  _join: Query!
}

type Query {
  usersDb_findFirstChat(where: usersDb_ChatWhereInput, orderBy: [usersDb_ChatOrderByWithRelationInput], cursor: usersDb_ChatWhereUniqueInput, take: Int, skip: Int, distinct: [usersDb_ChatScalarFieldEnum]): usersDb_Chat
  usersDb_findManyChat(where: usersDb_ChatWhereInput, orderBy: [usersDb_ChatOrderByWithRelationInput], cursor: usersDb_ChatWhereUniqueInput, take: Int, skip: Int, distinct: [usersDb_ChatScalarFieldEnum]): [usersDb_Chat]!
  usersDb_aggregateChat(where: usersDb_ChatWhereInput, orderBy: [usersDb_ChatOrderByWithRelationInput], cursor: usersDb_ChatWhereUniqueInput, take: Int, skip: Int): usersDb_AggregateChat!
  usersDb_groupByChat(where: usersDb_ChatWhereInput, orderBy: [usersDb_ChatOrderByWithAggregationInput], by: [usersDb_ChatScalarFieldEnum]!, having: usersDb_ChatScalarWhereWithAggregatesInput, take: Int, skip: Int): [usersDb_ChatGroupByOutputType]!
  usersDb_findUniqueChat(where: usersDb_ChatWhereUniqueInput!): usersDb_Chat
  usersDb_findFirstUser(where: usersDb_UserWhereInput, orderBy: [usersDb_UserOrderByWithRelationInput], cursor: usersDb_UserWhereUniqueInput, take: Int, skip: Int, distinct: [usersDb_UserScalarFieldEnum]): usersDb_User
  usersDb_findManyUser(where: usersDb_UserWhereInput, orderBy: [usersDb_UserOrderByWithRelationInput], cursor: usersDb_UserWhereUniqueInput, take: Int, skip: Int, distinct: [usersDb_UserScalarFieldEnum]): [usersDb_User]!
  usersDb_aggregateUser(where: usersDb_UserWhereInput, orderBy: [usersDb_UserOrderByWithRelationInput], cursor: usersDb_UserWhereUniqueInput, take: Int, skip: Int): usersDb_AggregateUser!
  usersDb_groupByUser(where: usersDb_UserWhereInput, orderBy: [usersDb_UserOrderByWithAggregationInput], by: [usersDb_UserScalarFieldEnum]!, having: usersDb_UserScalarWhereWithAggregatesInput, take: Int, skip: Int): [usersDb_UserGroupByOutputType]!
  usersDb_findUniqueUser(where: usersDb_UserWhereUniqueInput!): usersDb_User
}

input usersDb_UserCreateWithoutChatInput {
  email: String!
  lastName: String!
  firstName: String!
  name: String!
  userId: String!
  avatarId: String
}

input usersDb_UserCreateOrConnectWithoutChatInput {
  where: usersDb_UserWhereUniqueInput!
  create: usersDb_UserCreateWithoutChatInput!
}

input usersDb_UserCreateNestedOneWithoutChatInput {
  create: usersDb_UserCreateWithoutChatInput
  connectOrCreate: usersDb_UserCreateOrConnectWithoutChatInput
  connect: usersDb_UserWhereUniqueInput
}

input usersDb_ChatCreateInput {
  message: String
  createdAt: DateTime
  User: usersDb_UserCreateNestedOneWithoutChatInput!
}

input usersDb_NullableStringFieldUpdateOperationsInput {
  set: String
}

input usersDb_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input usersDb_StringFieldUpdateOperationsInput {
  set: String
}

input usersDb_UserUpdateWithoutChatInput {
  email: usersDb_StringFieldUpdateOperationsInput
  lastName: usersDb_StringFieldUpdateOperationsInput
  firstName: usersDb_StringFieldUpdateOperationsInput
  name: usersDb_StringFieldUpdateOperationsInput
  userId: usersDb_StringFieldUpdateOperationsInput
  avatarId: usersDb_NullableStringFieldUpdateOperationsInput
}

input usersDb_UserUpsertWithoutChatInput {
  update: usersDb_UserUpdateWithoutChatInput!
  create: usersDb_UserCreateWithoutChatInput!
}

input usersDb_UserUpdateOneRequiredWithoutChatInput {
  create: usersDb_UserCreateWithoutChatInput
  connectOrCreate: usersDb_UserCreateOrConnectWithoutChatInput
  upsert: usersDb_UserUpsertWithoutChatInput
  connect: usersDb_UserWhereUniqueInput
  update: usersDb_UserUpdateWithoutChatInput
}

input usersDb_ChatUpdateInput {
  message: usersDb_NullableStringFieldUpdateOperationsInput
  createdAt: usersDb_DateTimeFieldUpdateOperationsInput
  User: usersDb_UserUpdateOneRequiredWithoutChatInput
}

input usersDb_ChatCreateManyInput {
  id: Int
  message: String
  createdAt: DateTime
  userId: Int!
}

type usersDb_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input usersDb_ChatUpdateManyMutationInput {
  message: usersDb_NullableStringFieldUpdateOperationsInput
  createdAt: usersDb_DateTimeFieldUpdateOperationsInput
}

input usersDb_ChatCreateWithoutUserInput {
  message: String
  createdAt: DateTime
}

input usersDb_ChatCreateOrConnectWithoutUserInput {
  where: usersDb_ChatWhereUniqueInput!
  create: usersDb_ChatCreateWithoutUserInput!
}

input usersDb_ChatCreateManyUserInput {
  id: Int
  message: String
  createdAt: DateTime
}

input usersDb_ChatCreateManyUserInputEnvelope {
  data: [usersDb_ChatCreateManyUserInput]!
  skipDuplicates: Boolean
}

input usersDb_ChatCreateNestedManyWithoutUserInput {
  create: usersDb_ChatCreateWithoutUserInput
  connectOrCreate: usersDb_ChatCreateOrConnectWithoutUserInput
  createMany: usersDb_ChatCreateManyUserInputEnvelope
  connect: usersDb_ChatWhereUniqueInput
}

input usersDb_UserCreateInput {
  email: String!
  lastName: String!
  firstName: String!
  name: String!
  userId: String!
  avatarId: String
  Chat: usersDb_ChatCreateNestedManyWithoutUserInput
}

input usersDb_ChatUpdateWithoutUserInput {
  message: usersDb_NullableStringFieldUpdateOperationsInput
  createdAt: usersDb_DateTimeFieldUpdateOperationsInput
}

input usersDb_ChatUpsertWithWhereUniqueWithoutUserInput {
  where: usersDb_ChatWhereUniqueInput!
  update: usersDb_ChatUpdateWithoutUserInput!
  create: usersDb_ChatCreateWithoutUserInput!
}

input usersDb_ChatUpdateWithWhereUniqueWithoutUserInput {
  where: usersDb_ChatWhereUniqueInput!
  data: usersDb_ChatUpdateWithoutUserInput!
}

input usersDb_ChatScalarWhereInput {
  AND: usersDb_ChatScalarWhereInput
  OR: [usersDb_ChatScalarWhereInput]
  NOT: usersDb_ChatScalarWhereInput
  id: usersDb_IntFilter
  message: usersDb_StringNullableFilter
  createdAt: usersDb_DateTimeFilter
  userId: usersDb_IntFilter
}

input usersDb_ChatUpdateManyWithWhereWithoutUserInput {
  where: usersDb_ChatScalarWhereInput!
  data: usersDb_ChatUpdateManyMutationInput!
}

input usersDb_ChatUpdateManyWithoutUserInput {
  create: usersDb_ChatCreateWithoutUserInput
  connectOrCreate: usersDb_ChatCreateOrConnectWithoutUserInput
  upsert: usersDb_ChatUpsertWithWhereUniqueWithoutUserInput
  createMany: usersDb_ChatCreateManyUserInputEnvelope
  connect: usersDb_ChatWhereUniqueInput
  set: usersDb_ChatWhereUniqueInput
  disconnect: usersDb_ChatWhereUniqueInput
  delete: usersDb_ChatWhereUniqueInput
  update: usersDb_ChatUpdateWithWhereUniqueWithoutUserInput
  updateMany: usersDb_ChatUpdateManyWithWhereWithoutUserInput
  deleteMany: usersDb_ChatScalarWhereInput
}

input usersDb_UserUpdateInput {
  email: usersDb_StringFieldUpdateOperationsInput
  lastName: usersDb_StringFieldUpdateOperationsInput
  firstName: usersDb_StringFieldUpdateOperationsInput
  name: usersDb_StringFieldUpdateOperationsInput
  userId: usersDb_StringFieldUpdateOperationsInput
  avatarId: usersDb_NullableStringFieldUpdateOperationsInput
  Chat: usersDb_ChatUpdateManyWithoutUserInput
}

input usersDb_UserCreateManyInput {
  id: Int
  email: String!
  lastName: String!
  firstName: String!
  name: String!
  userId: String!
  avatarId: String
}

input usersDb_UserUpdateManyMutationInput {
  email: usersDb_StringFieldUpdateOperationsInput
  lastName: usersDb_StringFieldUpdateOperationsInput
  firstName: usersDb_StringFieldUpdateOperationsInput
  name: usersDb_StringFieldUpdateOperationsInput
  userId: usersDb_StringFieldUpdateOperationsInput
  avatarId: usersDb_NullableStringFieldUpdateOperationsInput
}

type Mutation {
  usersDb_createOneChat(data: usersDb_ChatCreateInput!): usersDb_Chat
  usersDb_upsertOneChat(where: usersDb_ChatWhereUniqueInput!, create: usersDb_ChatCreateInput!, update: usersDb_ChatUpdateInput!): usersDb_Chat
  usersDb_createManyChat(data: [usersDb_ChatCreateManyInput]!, skipDuplicates: Boolean): usersDb_AffectedRowsOutput
  usersDb_deleteOneChat(where: usersDb_ChatWhereUniqueInput!): usersDb_Chat
  usersDb_updateOneChat(data: usersDb_ChatUpdateInput!, where: usersDb_ChatWhereUniqueInput!): usersDb_Chat
  usersDb_updateManyChat(data: usersDb_ChatUpdateManyMutationInput!, where: usersDb_ChatWhereInput): usersDb_AffectedRowsOutput
  usersDb_deleteManyChat(where: usersDb_ChatWhereInput): usersDb_AffectedRowsOutput
  usersDb_createOneUser(data: usersDb_UserCreateInput!): usersDb_User
  usersDb_upsertOneUser(where: usersDb_UserWhereUniqueInput!, create: usersDb_UserCreateInput!, update: usersDb_UserUpdateInput!): usersDb_User
  usersDb_createManyUser(data: [usersDb_UserCreateManyInput]!, skipDuplicates: Boolean): usersDb_AffectedRowsOutput
  usersDb_deleteOneUser(where: usersDb_UserWhereUniqueInput!): usersDb_User
  usersDb_updateOneUser(data: usersDb_UserUpdateInput!, where: usersDb_UserWhereUniqueInput!): usersDb_User
  usersDb_updateManyUser(data: usersDb_UserUpdateManyMutationInput!, where: usersDb_UserWhereInput): usersDb_AffectedRowsOutput
  usersDb_deleteManyUser(where: usersDb_UserWhereInput): usersDb_AffectedRowsOutput
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

enum Claim {
  EMAIL
  EMAIL_VERIFIED
  NAME
  NICKNAME
  LOCATION
  PROVIDER
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  admin
  user
}

enum WunderGraphDateTimeFormat {
  """2006-01-02T15:04:05-0700"""
  ISO8601
  """Mon Jan _2 15:04:05 2006"""
  ANSIC
  """Mon Jan _2 15:04:05 MST 2006"""
  UnixDate
  """Mon Jan 02 15:04:05 -0700 2006"""
  RubyDate
  """02 Jan 06 15:04 MST"""
  RFC822
  """02 Jan 06 15:04 -0700"""
  RFC822Z
  """Monday, 02-Jan-06 15:04:05 MST"""
  RFC850
  """Mon, 02 Jan 2006 15:04:05 MST"""
  RFC1123
  """Mon, 02 Jan 2006 15:04:05 -0700"""
  RFC1123Z
  """2006-01-02T15:04:05Z07:00"""
  RFC3339
  """2006-01-02T15:04:05.999999999Z07:00"""
  RFC3339Nano
  """3:04PM"""
  Kitchen
  """Jan _2 15:04:05"""
  Stamp
  """Jan _2 15:04:05.000"""
  StampMilli
  """Jan _2 15:04:05.000000"""
  StampMicro
  """Jan _2 15:04:05.000000000"""
  StampNano
}
